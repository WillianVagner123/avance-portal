generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

enum UserStatus {
  PENDING
  ACTIVE
  DENIED
}

enum UserRole {
  MASTER
  PROFESSIONAL
}

model User {
  id                String     @id @default(cuid())
  email             String     @unique
  name              String?
  status            UserStatus @default(PENDING)
  role              UserRole   @default(PROFESSIONAL)
  konsistMedicoNome String?

  /// A hashed password for credentials based authentication.
  /// When a user registers using email/password, we store the password
  /// here using a secure hashing algorithm (bcrypt).  This field is optional
  /// to preserve backwards compatibility with Googleâ€‘authenticated accounts.
  password String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  accessRequests AccessRequest[]

  professionalLinkRequests ProfessionalLinkRequest[]

  googleCalendarLink     GoogleCalendarLink?
  konsistProfessionalMap KonsistProfessionalMap?
  googleCalendarEvents   GoogleCalendarEvent[]
}

enum RequestStatus {
  PENDING
  APPROVED
  DENIED
}

model AccessRequest {
  id     String        @id @default(cuid())
  email  String
  name   String?
  status RequestStatus @default(PENDING)

  reviewedBy String?
  reviewedAt DateTime?

  userId String?
  user   User?   @relation(fields: [userId], references: [id])

  createdAt DateTime @default(now())
}

model GoogleCalendarLink {
  id           String    @id @default(cuid())
  userId       String    @unique
  accessToken  String?
  refreshToken String?
  expiryDate   DateTime?
  approved     Boolean   @default(false)
  calendarId   String?
  calendarName String?
  syncToken    String?
  approvedAt   DateTime?
  approvedById String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model GoogleCalendarEvent {
  id String @id @default(cuid())

  userId        String
  googleEventId String
  calendarId    String
  status        String?
  summary       String?
  start         DateTime?
  end           DateTime?
  updated       DateTime?
  raw           Json?

  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt  DateTime @default(now())
  updatedAt2 DateTime @updatedAt

  @@unique([userId, googleEventId], name: "userId_googleEventId")
}

model KonsistProfessionalMap {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id])

  konsistProfissionalNome String
  konsistProfissionalId   String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ProfessionalLinkRequest {
  id     String        @id @default(cuid())
  userId String
  user   User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  requestedProfessional String
  status               RequestStatus @default(PENDING)

  reviewedBy String?
  reviewedAt DateTime?
  approvedProfessional String?

  createdAt DateTime @default(now())

  @@index([userId, status])
}
model PasswordResetToken {
  id        String   @id @default(uuid())
  userId    String
  tokenHash String
  expiresAt DateTime
  used      Boolean  @default(false)

  user User @relation(fields: [userId], references: [id])

  @@index([userId])
}
